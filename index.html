<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen & Audio Recorder - Free Online Recording Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-align: center;
        }

        .subtitle {
            text-align: center;
            opacity: 0.9;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .recording-info {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .recording-info.active {
            display: block;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .timer {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        .status {
            text-align: center;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background: #ff4444;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .recording-mode {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .mode-label {
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .mode-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .mode-option {
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .mode-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .mode-option.selected {
            background: rgba(255, 255, 255, 0.25);
            border-color: #43e97b;
        }

        .mode-option input {
            display: none;
        }

        .mode-icon {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            flex: 1;
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: #1a1a2e;
        }

        .btn-start:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(67, 233, 123, 0.4);
        }

        .btn-stop {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #1a1a2e;
        }

        .btn-stop:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(250, 112, 154, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .options {
            margin-bottom: 25px;
        }

        .option-group {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .option-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
        }

        select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            font-size: 1em;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .info h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .info ul {
            list-style: none;
            padding-left: 0;
        }

        .info li {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info li:before {
            content: "‚úì";
            color: #43e97b;
            font-weight: bold;
            font-size: 1.2em;
        }

        .error, .warning {
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }

        .error {
            background: rgba(255, 67, 54, 0.2);
            border: 2px solid rgba(255, 67, 54, 0.5);
        }

        .warning {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid rgba(255, 193, 7, 0.5);
        }

        .error.active, .warning.active {
            display: block;
        }

        .footer {
            margin-top: 30px;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9em;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 480px) {
            .mode-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Screen & Audio Recorder</h1>
        <p class="subtitle">Record screen, audio, or both - all in your browser</p>

        <div class="recording-info" id="recordingInfo">
            <div class="timer" id="timer">00:00:00</div>
            <div class="status">
                <div class="recording-dot"></div>
                <span id="recordingStatus">Recording in progress...</span>
            </div>
        </div>

        <div class="recording-mode">
            <span class="mode-label">Recording Mode:</span>
            <div class="mode-options">
                <label class="mode-option selected">
                    <input type="radio" name="mode" value="screen-audio" checked>
                    <div class="mode-icon">üñ•Ô∏èüéµ</div>
                    <div>Screen + Audio</div>
                </label>
                <label class="mode-option">
                    <input type="radio" name="mode" value="screen-only">
                    <div class="mode-icon">üñ•Ô∏è</div>
                    <div>Screen Only</div>
                </label>
                <label class="mode-option">
                    <input type="radio" name="mode" value="audio-only">
                    <div class="mode-icon">üéµ</div>
                    <div>Audio Only</div>
                </label>
                <label class="mode-option">
                    <input type="radio" name="mode" value="camera">
                    <div class="mode-icon">üì∑</div>
                    <div>Camera</div>
                </label>
            </div>
        </div>

        <div class="options">
            <div class="option-group" id="qualityGroup">
                <label for="quality">Video Quality:</label>
                <select id="quality">
                    <option value="1080">1080p (Full HD)</option>
                    <option value="720" selected>720p (HD)</option>
                    <option value="480">480p (SD)</option>
                    <option value="360">360p (Low)</option>
                </select>
            </div>

            <div class="option-group" id="audioSourceGroup">
                <label for="audioSource">Audio Source:</label>
                <select id="audioSource">
                    <option value="system">System/Tab Audio</option>
                    <option value="microphone">Microphone</option>
                    <option value="both">Both (System + Mic)</option>
                </select>
            </div>

            <div class="option-group">
                <label for="format">Output Format:</label>
                <select id="format">
                    <option value="webm">WebM (Recommended)</option>
                    <option value="mp4">MP4 (if supported)</option>
                </select>
            </div>
        </div>

        <div class="buttons">
            <button id="startBtn" class="btn-start">Start Recording</button>
            <button id="stopBtn" class="btn-stop" disabled>Stop Recording</button>
        </div>

        <div class="error" id="errorMsg"></div>
        <div class="warning" id="warningMsg"></div>

        <div class="info">
            <h3>Tips:</h3>
            <ul>
                <li>For best quality, use Chrome or Edge browser</li>
                <li>System audio recording works best when recording a tab</li>
                <li>Microphone requires separate permission</li>
                <li>Files save automatically to Downloads folder</li>
            </ul>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let recordedChunks = [];
        let startTime;
        let timerInterval;
        let stream;
        let audioStream;
        let combinedStream;

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordingInfo = document.getElementById('recordingInfo');
        const timer = document.getElementById('timer');
        const errorMsg = document.getElementById('errorMsg');
        const warningMsg = document.getElementById('warningMsg');
        const qualitySelect = document.getElementById('quality');
        const formatSelect = document.getElementById('format');
        const audioSourceSelect = document.getElementById('audioSource');
        const modeOptions = document.querySelectorAll('input[name="mode"]');
        const qualityGroup = document.getElementById('qualityGroup');
        const audioSourceGroup = document.getElementById('audioSourceGroup');
        const recordingStatus = document.getElementById('recordingStatus');

        // Update UI based on selected mode
        modeOptions.forEach(option => {
            option.addEventListener('change', updateUIForMode);
        });

        document.querySelectorAll('.mode-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.mode-option').forEach(opt => opt.classList.remove('selected'));
                this.classList.add('selected');
                this.querySelector('input').checked = true;
                updateUIForMode();
            });
        });

        function updateUIForMode() {
            const selectedMode = document.querySelector('input[name="mode"]:checked').value;
            
            if (selectedMode === 'audio-only') {
                qualityGroup.classList.add('hidden');
                audioSourceGroup.classList.remove('hidden');
                // Change audio source default for audio-only mode
                if (audioSourceSelect.value === 'system') {
                    audioSourceSelect.value = 'microphone';
                }
            } else if (selectedMode === 'screen-only') {
                qualityGroup.classList.remove('hidden');
                audioSourceGroup.classList.add('hidden');
            } else if (selectedMode === 'camera') {
                qualityGroup.classList.remove('hidden');
                audioSourceGroup.classList.remove('hidden');
                if (audioSourceSelect.value === 'system') {
                    audioSourceSelect.value = 'microphone';
                }
            } else {
                qualityGroup.classList.remove('hidden');
                audioSourceGroup.classList.remove('hidden');
            }
        }

        // Check browser support
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            showError('Your browser does not support screen recording. Please use Chrome, Edge, or Firefox.');
            startBtn.disabled = true;
        }

        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);

        async function startRecording() {
            try {
                errorMsg.classList.remove('active');
                warningMsg.classList.remove('active');
                recordedChunks = [];
                
                const selectedMode = document.querySelector('input[name="mode"]:checked').value;
                const quality = qualitySelect.value;
                const audioSource = audioSourceSelect.value;
                
                // Get quality settings
                const qualitySettings = getQualitySettings(quality);
                
                if (selectedMode === 'audio-only') {
                    // Audio only recording
                    recordingStatus.textContent = 'Recording audio...';
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        },
                        video: false 
                    });
                } else if (selectedMode === 'camera') {
                    // Camera recording
                    recordingStatus.textContent = 'Recording camera...';
                    const constraints = {
                        video: {
                            width: qualitySettings.width,
                            height: qualitySettings.height,
                            frameRate: qualitySettings.frameRate
                        },
                        audio: audioSource !== 'system'
                    };
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                } else if (selectedMode === 'screen-only') {
                    // Screen only recording
                    recordingStatus.textContent = 'Recording screen...';
                    stream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            width: qualitySettings.width,
                            height: qualitySettings.height,
                            frameRate: qualitySettings.frameRate
                        },
                        audio: false
                    });
                } else {
                    // Screen + Audio recording
                    recordingStatus.textContent = 'Recording screen and audio...';
                    
                    // First get screen with system audio if requested
                    const screenConstraints = {
                        video: {
                            width: qualitySettings.width,
                            height: qualitySettings.height,
                            frameRate: qualitySettings.frameRate
                        },
                        audio: audioSource === 'system' || audioSource === 'both'
                    };
                    
                    stream = await navigator.mediaDevices.getDisplayMedia(screenConstraints);
                    
                    // If user wants microphone audio
                    if (audioSource === 'microphone' || audioSource === 'both') {
                        try {
                            audioStream = await navigator.mediaDevices.getUserMedia({ 
                                audio: {
                                    echoCancellation: false,
                                    noiseSuppression: false,
                                    autoGainControl: false
                                },
                                video: false 
                            });
                            
                            // Combine streams if we have both
                            if (audioSource === 'both' && stream.getAudioTracks().length > 0) {
                                combinedStream = new MediaStream([
                                    ...stream.getVideoTracks(),
                                    ...stream.getAudioTracks(),
                                    ...audioStream.getAudioTracks()
                                ]);
                                showWarning('Recording both system and microphone audio. Both will be mixed in the output.');
                            } else if (audioSource === 'microphone') {
                                // Replace system audio with microphone
                                combinedStream = new MediaStream([
                                    ...stream.getVideoTracks(),
                                    ...audioStream.getAudioTracks()
                                ]);
                            }
                        } catch (audioError) {
                            console.warn('Failed to get microphone:', audioError);
                            showWarning('Microphone access denied. Recording without microphone audio.');
                        }
                    }
                }

                // Use combined stream if available, otherwise use the main stream
                const recordingStream = combinedStream || stream;

                if (!recordingStream || recordingStream.getTracks().length === 0) {
                    throw new Error('No media tracks available for recording');
                }

                // Determine MIME type
                let mimeType = getMimeType(selectedMode);
                
                // Create MediaRecorder
                const recorderOptions = {
                    mimeType: mimeType
                };
                
                // Add bitrate for video modes
                if (selectedMode !== 'audio-only') {
                    recorderOptions.videoBitsPerSecond = qualitySettings.bitrate;
                }
                
                mediaRecorder = new MediaRecorder(recordingStream, recorderOptions);

                // Collect data
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                        console.log('Data chunk received:', event.data.size, 'bytes');
                    }
                };

                // Handle recording stop
                mediaRecorder.onstop = () => {
                    console.log('Recording stopped, chunks:', recordedChunks.length);
                    handleStop(selectedMode);
                };

                // Handle errors
                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event);
                    showError('Recording error occurred. Please try again.');
                    stopRecording();
                };

                // Handle stream end (user stops sharing)
                recordingStream.getTracks().forEach(track => {
                    track.onended = () => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            stopRecording();
                        }
                    };
                });

                // Start recording
                mediaRecorder.start(100); // Collect data every 100ms for better quality
                console.log('Recording started with', recordingStream.getTracks().length, 'tracks');

                // Update UI
                startBtn.disabled = true;
                stopBtn.disabled = false;
                recordingInfo.classList.add('active');
                
                // Start timer
                startTime = Date.now();
                updateTimer();
                timerInterval = setInterval(updateTimer, 1000);

            } catch (error) {
                console.error('Error starting recording:', error);
                
                if (error.name === 'NotAllowedError') {
                    showError('Permission denied. Please allow recording and try again.');
                } else if (error.name === 'NotFoundError') {
                    showError('No media source available for recording.');
                } else if (error.name === 'NotReadableError') {
                    showError('Could not access media device. It may be in use by another application.');
                } else {
                    showError(`Failed to start recording: ${error.message}`);
                }
            }
        }

        function stopRecording() {
            console.log('Stopping recording...');
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Stop all tracks
            [stream, audioStream, combinedStream].forEach(s => {
                if (s) {
                    s.getTracks().forEach(track => track.stop());
                }
            });
            
            stream = null;
            audioStream = null;
            combinedStream = null;

            // Clear timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Update UI
            startBtn.disabled = false;
            stopBtn.disabled = true;
            recordingInfo.classList.remove('active');
        }

        function handleStop(mode) {
            if (recordedChunks.length === 0) {
                showError('No data was recorded. Please try again.');
                return;
            }

            // Calculate total size
            const totalSize = recordedChunks.reduce((acc, chunk) => acc + chunk.size, 0);
            console.log('Total recording size:', totalSize, 'bytes');

            if (totalSize === 0) {
                showError('Recording is empty. Please check your settings and try again.');
                return;
            }

            // Create blob
            const mimeType = getMimeType(mode);
            const blob = new Blob(recordedChunks, { type: mimeType });
            console.log('Created blob:', blob.size, 'bytes, type:', blob.type);

            // Determine file extension
            let extension = 'webm';
            if (mode === 'audio-only') {
                extension = 'webm'; // Audio will be in WebM container
            } else if (formatSelect.value === 'mp4' && mimeType.includes('mp4')) {
                extension = 'mp4';
            }

            // Create download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            
            // Generate filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const prefix = mode === 'audio-only' ? 'audio' : 'recording';
            a.download = `${prefix}-${timestamp}.${extension}`;
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);

            // Clear chunks for next recording
            recordedChunks = [];
        }

        function getQualitySettings(quality) {
            const settings = {
                '1080': { 
                    width: { ideal: 1920, max: 1920 }, 
                    height: { ideal: 1080, max: 1080 }, 
                    frameRate: { ideal: 30, max: 30 },
                    bitrate: 8000000 // 8 Mbps
                },
                '720': { 
                    width: { ideal: 1280, max: 1280 }, 
                    height: { ideal: 720, max: 720 }, 
                    frameRate: { ideal: 30, max: 30 },
                    bitrate: 4000000 // 4 Mbps
                },
                '480': { 
                    width: { ideal: 854, max: 854 }, 
                    height: { ideal: 480, max: 480 }, 
                    frameRate: { ideal: 24, max: 30 },
                    bitrate: 2000000 // 2 Mbps
                },
                '360': { 
                    width: { ideal: 640, max: 640 }, 
                    height: { ideal: 360, max: 360 }, 
                    frameRate: { ideal: 24, max: 24 },
                    bitrate: 1000000 // 1 Mbps
                }
            };
            return settings[quality] || settings['720'];
        }

        function getMimeType(mode) {
            const format = formatSelect.value;
            
            // For audio-only, use audio-specific codecs
            if (mode === 'audio-only') {
                // Try Opus first (best quality), then fall back
                const audioTypes = [
                    'audio/webm;codecs=opus',
                    'audio/webm',
                    'audio/ogg;codecs=opus'
                ];
                
                for (let type of audioTypes) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        console.log('Using audio MIME type:', type);
                        return type;
                    }
                }
            }
            
            // For video modes
            if (format === 'mp4') {
                const mp4Types = [
                    'video/mp4;codecs=h264,aac',
                    'video/mp4;codecs=h264',
                    'video/mp4;codecs=avc1',
                    'video/mp4'
                ];
                
                for (let type of mp4Types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        console.log('Using MP4 MIME type:', type);
                        return type;
                    }
                }
            }
            
            // Default to WebM with best supported codecs
            const webmTypes = [
                'video/webm;codecs=vp9,opus',
                'video/webm;codecs=vp8,opus',
                'video/webm;codecs=h264,opus',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm'
            ];
            
            for (let type of webmTypes) {
                if (MediaRecorder.isTypeSupported(type)) {
                    console.log('Using WebM MIME type:', type);
                    return type;
                }
            }
            
            // Final fallback
            console.log('Using default MIME type');
            return 'video/webm';
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const hours = Math.floor(elapsed / 3600);
            const minutes = Math.floor((elapsed % 3600) / 60);
            const seconds = elapsed % 60;
            
            timer.textContent = 
                String(hours).padStart(2, '0') + ':' +
                String(minutes).padStart(2, '0') + ':' +
                String(seconds).padStart(2, '0');
        }

        function showError(message) {
            errorMsg.textContent = message;
            errorMsg.classList.add('active');
            setTimeout(() => errorMsg.classList.remove('active'), 10000);
        }

        function showWarning(message) {
            warningMsg.textContent = message;
            warningMsg.classList.add('active');
            setTimeout(() => warningMsg.classList.remove('active'), 10000);
        }

        // Initialize UI
        updateUIForMode();
    </script>
</body>
</html>
